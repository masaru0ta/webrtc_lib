<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>エアホッケー - WebRTC-GAS サンプル</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      max-width: 450px;
      width: 100%;
      text-align: center;
    }

    h1 {
      color: #333;
      margin-bottom: 20px;
      font-size: 24px;
    }

    .screen {
      display: none;
    }

    .screen.active {
      display: block;
    }

    .player-info {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .name-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .player-name {
      font-size: 20px;
      font-weight: bold;
      color: #e94560;
    }

    .btn-edit-name {
      background: none;
      border: 1px solid #ccc;
      color: #666;
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-edit-name:hover {
      border-color: #e94560;
      color: #e94560;
    }

    .player-id {
      font-size: 12px;
      color: #999;
      margin-top: 5px;
    }

    .btn {
      background: linear-gradient(135deg, #e94560 0%, #0f3460 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 16px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      width: 100%;
      margin-bottom: 10px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: #f5f5f5;
      color: #333;
    }

    .btn-secondary:hover {
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }

    .status {
      color: #666;
      margin: 15px 0;
      font-size: 14px;
    }

    .status.error {
      color: #e74c3c;
    }

    /* ゲーム画面 */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .score-display {
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 24px;
      font-weight: bold;
    }

    .score {
      padding: 10px 20px;
      border-radius: 10px;
      min-width: 60px;
    }

    .score.opponent {
      background: #e94560;
      color: white;
    }

    .score.mine {
      background: #0f3460;
      color: white;
    }

    .score-separator {
      color: #333;
    }

    .opponent-name {
      font-size: 14px;
      color: #666;
    }

    #game-canvas {
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      touch-action: none;
      max-width: 100%;
    }

    .result {
      font-size: 24px;
      font-weight: bold;
      margin: 20px 0;
      padding: 15px;
      border-radius: 10px;
    }

    .result.win {
      background: #d4edda;
      color: #155724;
    }

    .result.lose {
      background: #f8d7da;
      color: #721c24;
    }

    .game-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .game-buttons .btn {
      flex: 1;
    }

    /* ローディング */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #e94560;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* 設定セクション */
    .settings-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .settings-toggle {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      width: 100%;
      padding: 10px;
    }

    .settings-toggle:hover {
      color: #e94560;
    }

    .settings-toggle .arrow {
      transition: transform 0.3s;
    }

    .settings-toggle.open .arrow {
      transform: rotate(180deg);
    }

    .settings-content {
      display: none;
      margin-top: 15px;
    }

    .settings-content.open {
      display: block;
    }

    .setting-item {
      margin-bottom: 15px;
      text-align: left;
    }

    .setting-label {
      font-size: 14px;
      color: #333;
      margin-bottom: 5px;
      display: block;
    }

    .setting-input {
      width: 100%;
      padding: 10px 15px;
      border: 2px solid #eee;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.2s;
    }

    .setting-input:focus {
      outline: none;
      border-color: #e94560;
    }

    .setting-help {
      font-size: 12px;
      color: #999;
      margin-top: 5px;
    }

    .friend-list-container {
      max-height: 150px;
      overflow-y: auto;
      border: 2px solid #eee;
      border-radius: 8px;
      padding: 10px;
    }

    .friend-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: #f9f9f9;
      border-radius: 5px;
      margin-bottom: 5px;
      font-size: 13px;
    }

    .friend-item:last-child {
      margin-bottom: 0;
    }

    .friend-id {
      color: #666;
      font-family: monospace;
    }

    .friend-remove {
      background: none;
      border: none;
      color: #e94560;
      cursor: pointer;
      font-size: 16px;
      padding: 0 5px;
    }

    .friend-remove:hover {
      color: #c13050;
    }

    .add-friend-row {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .add-friend-row input {
      flex: 1;
    }

    .btn-add-friend {
      padding: 10px 15px;
      background: #e94560;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
    }

    .btn-add-friend:hover {
      background: #c13050;
    }

    .empty-list {
      color: #999;
      font-size: 13px;
      text-align: center;
      padding: 20px;
    }

    .back-link {
      display: inline-block;
      margin-bottom: 15px;
      color: #666;
      text-decoration: none;
      font-size: 14px;
    }

    .back-link:hover {
      color: #e94560;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="../index.html" class="back-link">← ゲーム一覧に戻る</a>
    <h1>エアホッケー</h1>

    <!-- ロビー画面 -->
    <div id="screen-lobby" class="screen active">
      <div class="player-info">
        <div class="name-row">
          <span class="player-name" id="my-name">-</span>
          <button class="btn-edit-name" id="btn-edit-name">編集</button>
        </div>
        <div class="player-id" id="my-id">ID: -</div>
      </div>

      <button class="btn" id="btn-start">マッチング開始</button>

      <div class="status" id="status">準備完了</div>

      <!-- 設定セクション -->
      <div class="settings-section">
        <button class="settings-toggle" id="settings-toggle">
          <span>設定</span>
          <span class="arrow">▼</span>
        </button>
        <div class="settings-content" id="settings-content">
          <!-- あいことば設定 -->
          <div class="setting-item">
            <label class="setting-label">あいことば</label>
            <input type="text" class="setting-input" id="input-passphrase" placeholder="あいことばを入力">
            <div class="setting-help">同じあいことばを設定した人とのみマッチングします</div>
          </div>

          <!-- フレンドリスト設定 -->
          <div class="setting-item">
            <label class="setting-label">フレンドリスト</label>
            <div class="friend-list-container" id="friend-list-container">
              <div class="empty-list" id="empty-friend-list">フレンドがいません</div>
            </div>
            <div class="add-friend-row">
              <input type="text" class="setting-input" id="input-friend-id" placeholder="フレンドIDを入力">
              <button class="btn-add-friend" id="btn-add-friend">追加</button>
            </div>
            <div class="setting-help">フレンドIDを追加すると、そのプレイヤーと優先的にマッチングします</div>
          </div>
        </div>
      </div>
    </div>

    <!-- ゲーム画面 -->
    <div id="screen-game" class="screen">
      <div class="game-header">
        <div class="opponent-name">VS <span id="opponent-name">-</span></div>
        <div class="score-display">
          <div class="score opponent" id="opponent-score">0</div>
          <span class="score-separator">-</span>
          <div class="score mine" id="my-score">0</div>
        </div>
      </div>

      <canvas id="game-canvas" width="400" height="500"></canvas>

      <div class="result" id="result" style="display: none;"></div>

      <div class="game-buttons">
        <button class="btn" id="btn-rematch" style="display: none;">もう一度</button>
        <button class="btn btn-secondary" id="btn-disconnect">切断</button>
      </div>
    </div>
  </div>

  <script src="../src/webrtc-gas.js"></script>
  <script>
    // ========================================
    // 定数
    // ========================================
    const API_URL = 'https://script.google.com/macros/s/AKfycbz9RbzxrYV8QbsclJcwNYhO4JoE9qQZlD-aWX5Z5U9jICPBEiBbEznf3scgQx8GONZa1A/exec';

    const ZODIAC_NAMES = [
      'ねずみ', 'うし', 'とら', 'うさぎ', 'たつ', 'へび',
      'うま', 'ひつじ', 'さる', 'とり', 'いぬ', 'いのしし'
    ];

    const STORAGE_KEYS = {
      MY_ID: 'airhockey_myId',
      MY_NAME: 'airhockey_myName',
      FRIEND_LIST: 'airhockey_friendList',
      PASSPHRASE: 'airhockey_passphrase'
    };

    // ゲーム定数
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 500;
    const PADDLE_RADIUS = 30; // 丸いパドル
    const PUCK_RADIUS = 15;
    const GOAL_WIDTH = 120;
    const WINNING_SCORE = 5;
    const PUCK_SPEED = 5;

    // 物理定数
    const FRICTION = 0.995;       // 摩擦係数（毎フレーム速度に掛ける）
    const RESTITUTION = 0.9;      // 反発係数（壁・パドル衝突時）
    const PUCK_SPEED_LIMIT = 15;  // パックの最高速度

    // ========================================
    // サウンド
    // ========================================
    let audioContext = null;

    // AudioContextを初期化（ユーザー操作後に呼び出す）
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    // BEEP音を鳴らす
    function playBeep(frequency = 440, duration = 0.05, volume = 0.3) {
      if (!audioContext) return;

      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.frequency.value = frequency;
      oscillator.type = 'square';

      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }

    // 壁衝突音（低め）
    function playWallHit() {
      playBeep(220, 0.05, 0.2);
    }

    // パドル衝突音（高め）
    function playPaddleHit() {
      playBeep(440, 0.08, 0.3);
    }

    // ゴール音（ファンファーレ風）
    function playGoalSound(isMyGoal) {
      if (!audioContext) return;

      if (isMyGoal) {
        // 失点：下降音
        playBeep(400, 0.15, 0.3);
        setTimeout(() => playBeep(300, 0.15, 0.3), 150);
        setTimeout(() => playBeep(200, 0.3, 0.3), 300);
      } else {
        // 得点：上昇ファンファーレ
        playBeep(523, 0.1, 0.3);  // C5
        setTimeout(() => playBeep(659, 0.1, 0.3), 100);  // E5
        setTimeout(() => playBeep(784, 0.1, 0.3), 200);  // G5
        setTimeout(() => playBeep(1047, 0.3, 0.4), 300); // C6
      }
    }

    // ========================================
    // ゴール演出
    // ========================================
    let goalEffect = null;

    function startGoalEffect(scorerIsHost) {
      // 自分のゴールかどうか判定
      const isMyGoal = (isHost && scorerIsHost) || (!isHost && !scorerIsHost);

      // サウンド再生
      playGoalSound(!isMyGoal);

      goalEffect = {
        startTime: Date.now(),
        duration: 1500,  // 1.5秒
        isMyGoal: isMyGoal,
        particles: [],
        flashAlpha: 1.0
      };

      // パーティクル生成（花火のように放射状に広がる）
      const goalY = isMyGoal ? CANVAS_HEIGHT : 0;
      const colors = isMyGoal ?
        ['#e94560', '#ff6b8a', '#ff8fa3', '#ffb3c1'] :
        ['#4CAF50', '#66BB6A', '#81C784', '#A5D6A7', '#FFD700', '#FFC107'];

      for (let i = 0; i < 40; i++) {
        // 放射状に広がる角度を計算
        const angle = (Math.PI * 2 * i / 40) + (Math.random() - 0.5) * 0.3;
        const speed = Math.random() * 8 + 4;

        goalEffect.particles.push({
          x: CANVAS_WIDTH / 2 + (Math.random() - 0.5) * 40,
          y: goalY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed * (isMyGoal ? -1 : 1),  // 常にフィールド内側に向かう
          size: Math.random() * 6 + 3,
          color: colors[Math.floor(Math.random() * colors.length)],
          alpha: 1.0,
          gravity: isMyGoal ? 0.2 : -0.2  // 重力方向もフィールド内側に
        });
      }

      // キラキラエフェクト追加
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        goalEffect.particles.push({
          x: CANVAS_WIDTH / 2 + (Math.random() - 0.5) * GOAL_WIDTH,
          y: goalY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed * (isMyGoal ? -1 : 1),
          size: Math.random() * 3 + 1,
          color: '#ffffff',
          alpha: 1.0,
          gravity: isMyGoal ? 0.1 : -0.1,
          isSpark: true
        });
      }
    }

    function updateGoalEffect() {
      if (!goalEffect) return false;

      const elapsed = Date.now() - goalEffect.startTime;
      if (elapsed > goalEffect.duration) {
        goalEffect = null;
        return false;
      }

      const progress = elapsed / goalEffect.duration;

      // フラッシュ効果の減衰
      goalEffect.flashAlpha = Math.max(0, 1 - progress * 2);

      // パーティクル更新
      goalEffect.particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity || 0.3;  // 個別の重力（未設定なら0.3）
        p.vx *= 0.98;  // 空気抵抗
        p.vy *= 0.98;
        p.alpha = 1 - progress;
        // スパークは早めにフェードアウト
        if (p.isSpark) {
          p.alpha = Math.max(0, 1 - progress * 1.5);
        }
      });

      return true;
    }

    function drawGoalEffect() {
      if (!goalEffect) return;

      // 画面フラッシュ
      if (goalEffect.flashAlpha > 0) {
        const flashColor = goalEffect.isMyGoal ?
          `rgba(233, 69, 96, ${goalEffect.flashAlpha * 0.3})` :
          `rgba(76, 175, 80, ${goalEffect.flashAlpha * 0.3})`;
        ctx.fillStyle = flashColor;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      }

      // パーティクル描画
      goalEffect.particles.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();

        // スパークには光彩効果を追加
        if (p.isSpark && p.alpha > 0.3) {
          ctx.globalAlpha = p.alpha * 0.5;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      ctx.globalAlpha = 1.0;

      // テキスト表示
      const elapsed = Date.now() - goalEffect.startTime;
      if (elapsed < 1000) {
        const scale = 1 + Math.sin(elapsed / 50) * 0.1;
        const textAlpha = Math.min(1, elapsed / 200);

        ctx.save();
        ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
        ctx.scale(scale, scale);

        ctx.globalAlpha = textAlpha;
        ctx.fillStyle = goalEffect.isMyGoal ? '#e94560' : '#4CAF50';
        ctx.font = 'bold 48px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // 縁取り
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 4;
        ctx.strokeText(goalEffect.isMyGoal ? '失点...' : 'GOAL!', 0, 0);
        ctx.fillText(goalEffect.isMyGoal ? '失点...' : 'GOAL!', 0, 0);

        ctx.restore();
      }
    }

    // ========================================
    // ゲーム状態
    // ========================================
    let client = null;
    let canvas = null;
    let ctx = null;
    let isHost = false;
    let gameOver = false;
    let animationId = null;

    // スコア
    let hostScore = 0;
    let guestScore = 0;

    // パドル位置（X, Y位置）
    let myPaddleX = CANVAS_WIDTH / 2;
    let myPaddleY = 0;
    let myPaddlePrevX = CANVAS_WIDTH / 2;  // 前フレームの位置（スウィープ衝突検出用）
    let myPaddlePrevY = 0;
    let opponentPaddleX = CANVAS_WIDTH / 2;
    let opponentPaddleY = 0;
    let opponentPaddlePrevX = CANVAS_WIDTH / 2;  // 前フレームの位置（スウィープ衝突検出用）
    let opponentPaddlePrevY = 0;

    // パック状態
    let puck = {
      x: CANVAS_WIDTH / 2,
      y: CANVAS_HEIGHT / 2,
      vx: 0,
      vy: 0
    };

    // 補間設定
    const LERP_FACTOR = 0.3;

    // ========================================
    // DOM要素
    // ========================================
    const elements = {
      screenLobby: document.getElementById('screen-lobby'),
      screenGame: document.getElementById('screen-game'),
      myName: document.getElementById('my-name'),
      myId: document.getElementById('my-id'),
      btnEditName: document.getElementById('btn-edit-name'),
      btnStart: document.getElementById('btn-start'),
      status: document.getElementById('status'),
      opponentName: document.getElementById('opponent-name'),
      opponentScore: document.getElementById('opponent-score'),
      myScore: document.getElementById('my-score'),
      gameCanvas: document.getElementById('game-canvas'),
      result: document.getElementById('result'),
      btnRematch: document.getElementById('btn-rematch'),
      btnDisconnect: document.getElementById('btn-disconnect'),
      // 設定関連
      settingsToggle: document.getElementById('settings-toggle'),
      settingsContent: document.getElementById('settings-content'),
      inputPassphrase: document.getElementById('input-passphrase'),
      friendListContainer: document.getElementById('friend-list-container'),
      emptyFriendList: document.getElementById('empty-friend-list'),
      inputFriendId: document.getElementById('input-friend-id'),
      btnAddFriend: document.getElementById('btn-add-friend')
    };

    // ========================================
    // localStorage 操作
    // ========================================
    function loadFromStorage() {
      return {
        myId: localStorage.getItem(STORAGE_KEYS.MY_ID) || null,
        myName: localStorage.getItem(STORAGE_KEYS.MY_NAME) || null,
        friendList: JSON.parse(localStorage.getItem(STORAGE_KEYS.FRIEND_LIST) || '[]'),
        passphrase: localStorage.getItem(STORAGE_KEYS.PASSPHRASE) || ''
      };
    }

    function saveToStorage(key, value) {
      if (key === STORAGE_KEYS.FRIEND_LIST) {
        localStorage.setItem(key, JSON.stringify(value));
      } else {
        localStorage.setItem(key, value);
      }
    }

    function addFriend(friendId) {
      const data = loadFromStorage();
      if (!data.friendList.includes(friendId)) {
        data.friendList.push(friendId);
        saveToStorage(STORAGE_KEYS.FRIEND_LIST, data.friendList);
      }
      return data.friendList;
    }

    function removeFriend(friendId) {
      const data = loadFromStorage();
      const newList = data.friendList.filter(id => id !== friendId);
      saveToStorage(STORAGE_KEYS.FRIEND_LIST, newList);
      return newList;
    }

    function renderFriendList(friendList) {
      // 既存のフレンドアイテムを削除（空リスト表示は残す）
      const items = elements.friendListContainer.querySelectorAll('.friend-item');
      items.forEach(item => item.remove());

      if (friendList.length === 0) {
        elements.emptyFriendList.style.display = 'block';
      } else {
        elements.emptyFriendList.style.display = 'none';
        friendList.forEach(friendId => {
          const item = document.createElement('div');
          item.className = 'friend-item';
          item.innerHTML = `
            <span class="friend-id">${friendId}</span>
            <button class="friend-remove" data-id="${friendId}">×</button>
          `;
          elements.friendListContainer.appendChild(item);
        });
      }
    }

    // ========================================
    // 名前生成
    // ========================================
    function generateName() {
      const index = Math.floor(Math.random() * ZODIAC_NAMES.length);
      return ZODIAC_NAMES[index];
    }

    // ========================================
    // グローバルIP取得
    // ========================================
    async function getGlobalIp() {
      try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return data.ip;
      } catch (error) {
        console.warn('グローバルIP取得失敗:', error);
        return '';
      }
    }

    // ========================================
    // 画面切り替え
    // ========================================
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
    }

    function setStatus(message, isError = false) {
      elements.status.textContent = message;
      elements.status.classList.toggle('error', isError);
    }

    // ========================================
    // 接続処理
    // ========================================

    // データチャネルが開くまで待機する関数
    function waitForDataChannel() {
      return new Promise((resolve) => {
        const checkInterval = setInterval(() => {
          if (client && client._dataChannel && client._dataChannel.readyState === 'open') {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
        // 最大10秒でタイムアウト
        setTimeout(() => {
          clearInterval(checkInterval);
          resolve();
        }, 10000);
      });
    }

    async function connectToPeer(peerId) {
      try {
        setStatus('接続中...');
        elements.btnStart.disabled = true;

        await client.connect(peerId);

      } catch (error) {
        setStatus('接続エラー: ' + error.message, true);
        elements.btnStart.disabled = false;
      }
    }

    // ========================================
    // ゲーム初期化
    // ========================================
    function initGame(isOfferer) {
      isHost = isOfferer;
      gameOver = false;
      hostScore = 0;
      guestScore = 0;

      // パドル初期位置（自分は常に下半分）
      myPaddleX = CANVAS_WIDTH / 2;
      myPaddleY = CANVAS_HEIGHT * 3 / 4;
      myPaddlePrevX = myPaddleX;
      myPaddlePrevY = myPaddleY;
      opponentPaddleX = CANVAS_WIDTH / 2;
      // 相手パドルの初期Y位置はホスト座標系で設定（描画時にゲストは反転する）
      // ホスト座標系では相手は上半分(1/4)にいる
      opponentPaddleY = CANVAS_HEIGHT / 4;
      opponentPaddlePrevX = opponentPaddleX;
      opponentPaddlePrevY = opponentPaddleY;

      // パック初期化
      resetPuck();

      // フレンドリストに追加
      const newFriendList = addFriend(client.peerId);
      renderFriendList(newFriendList);

      // UI更新
      elements.opponentName.textContent = client.peerName || client.peerId;
      updateScoreDisplay();
      elements.result.style.display = 'none';
      elements.btnRematch.style.display = 'none';

      showScreen('screen-game');

      // ゲームループ開始
      startGameLoop();
    }

    function resetPuck() {
      puck.x = CANVAS_WIDTH / 2;
      puck.y = CANVAS_HEIGHT / 2;
      puck.vx = 0;
      puck.vy = 0;
    }

    function updateScoreDisplay() {
      if (isHost) {
        elements.myScore.textContent = hostScore;
        elements.opponentScore.textContent = guestScore;
      } else {
        elements.myScore.textContent = guestScore;
        elements.opponentScore.textContent = hostScore;
      }
    }

    // ========================================
    // ゲームループ
    // ========================================
    function startGameLoop() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      gameLoop();
    }

    function stopGameLoop() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function gameLoop() {
      if (gameOver) return;

      // 両方で物理演算を実行（ローカルシミュレーション）
      updatePuck();

      // ゴール演出更新
      updateGoalEffect();

      // 描画
      draw();

      // ゴール演出描画
      drawGoalEffect();

      animationId = requestAnimationFrame(gameLoop);
    }

    // ========================================
    // 物理演算（両プレイヤーで実行）
    // ========================================
    function updatePuck() {
      // 摩擦を適用
      puck.vx *= FRICTION;
      puck.vy *= FRICTION;

      // 速度制限
      const speed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
      if (speed > PUCK_SPEED_LIMIT) {
        puck.vx = (puck.vx / speed) * PUCK_SPEED_LIMIT;
        puck.vy = (puck.vy / speed) * PUCK_SPEED_LIMIT;
      }

      // パック移動
      puck.x += puck.vx;
      puck.y += puck.vy;

      // 左右の壁との衝突（反発係数を適用）
      if (puck.x - PUCK_RADIUS <= 0) {
        puck.x = PUCK_RADIUS;
        puck.vx = -puck.vx * RESTITUTION;
        playWallHit();
      } else if (puck.x + PUCK_RADIUS >= CANVAS_WIDTH) {
        puck.x = CANVAS_WIDTH - PUCK_RADIUS;
        puck.vx = -puck.vx * RESTITUTION;
        playWallHit();
      }

      // ゴール判定（上下）
      const goalLeft = (CANVAS_WIDTH - GOAL_WIDTH) / 2;
      const goalRight = (CANVAS_WIDTH + GOAL_WIDTH) / 2;

      // 上ゴール（ゲストのゴール）- ホストのみ判定
      if (puck.y - PUCK_RADIUS <= 0) {
        if (puck.x >= goalLeft && puck.x <= goalRight) {
          if (isHost) {
            hostScore++;
            startGoalEffect(false);  // ゲストのゴールにホストが得点
            sendGoal('host');
            if (hostScore >= WINNING_SCORE) {
              endGame('host');
            } else {
              resetPuck();
              sendPuckState();
            }
          }
          return;
        } else {
          puck.y = PUCK_RADIUS;
          puck.vy = -puck.vy * RESTITUTION;
          playWallHit();
        }
      }

      // 下ゴール（ホストのゴール）- ホストのみ判定
      if (puck.y + PUCK_RADIUS >= CANVAS_HEIGHT) {
        if (puck.x >= goalLeft && puck.x <= goalRight) {
          if (isHost) {
            guestScore++;
            startGoalEffect(true);  // ホストのゴールにゲストが得点
            sendGoal('guest');
            if (guestScore >= WINNING_SCORE) {
              endGame('guest');
            } else {
              resetPuck();
              sendPuckState();
            }
          }
          return;
        } else {
          puck.y = CANVAS_HEIGHT - PUCK_RADIUS;
          puck.vy = -puck.vy * RESTITUTION;
          playWallHit();
        }
      }

      // パドルとの衝突判定はホストのみ（スウィープ衝突検出を使用）
      if (isHost) {
        // ホストのパドル（下半分）
        checkSweepPaddleCollision(myPaddleX, myPaddleY, myPaddlePrevX, myPaddlePrevY);
        // ゲストのパドル（上半分）
        checkSweepPaddleCollision(opponentPaddleX, opponentPaddleY, opponentPaddlePrevX, opponentPaddlePrevY);
        // パック状態を送信
        sendPuckState();
      }

      // パドルの前フレーム位置を更新
      myPaddlePrevX = myPaddleX;
      myPaddlePrevY = myPaddleY;
      opponentPaddlePrevX = opponentPaddleX;
      opponentPaddlePrevY = opponentPaddleY;
    }

    // スウィープ衝突検出：パドルの移動軌跡を考慮した衝突判定
    // パドルが高速移動してもすり抜けを防止
    function checkSweepPaddleCollision(paddleX, paddleY, prevX, prevY) {
      // パドルの移動線分: (prevX, prevY) -> (paddleX, paddleY)
      const lineX1 = prevX;
      const lineY1 = prevY;
      const lineX2 = paddleX;
      const lineY2 = paddleY;

      // 衝突半径（パドル半径 + パック半径）
      const collisionRadius = PADDLE_RADIUS + PUCK_RADIUS;

      // 線分の長さの2乗
      const lineLenSq = (lineX2 - lineX1) * (lineX2 - lineX1) +
                        (lineY2 - lineY1) * (lineY2 - lineY1);

      // パドルがほぼ動いていない場合は通常判定
      if (lineLenSq < 1) {
        return checkStaticPaddleCollision(paddleX, paddleY, 0, 0);
      }

      // パックの中心から線分への最近点を計算
      let t = ((puck.x - lineX1) * (lineX2 - lineX1) +
               (puck.y - lineY1) * (lineY2 - lineY1)) / lineLenSq;

      // tを0〜1にクランプ（線分上に制限）
      t = Math.max(0, Math.min(1, t));

      // 線分上の最近点
      const nearestX = lineX1 + t * (lineX2 - lineX1);
      const nearestY = lineY1 + t * (lineY2 - lineY1);

      // 最近点とパック中心の距離
      const dx = puck.x - nearestX;
      const dy = puck.y - nearestY;
      const distSq = dx * dx + dy * dy;

      // 衝突半径より近ければ衝突
      if (distSq < collisionRadius * collisionRadius) {
        // パドルの速度を計算（前フレームから現在への移動）
        const paddleVx = paddleX - prevX;
        const paddleVy = paddleY - prevY;
        return checkStaticPaddleCollision(paddleX, paddleY, paddleVx, paddleVy);
      }

      return false;
    }

    // パドルとパックの衝突判定（パドル速度を考慮）
    function checkStaticPaddleCollision(paddleX, paddleY, paddleVx, paddleVy) {
      const dx = puck.x - paddleX;
      const dy = puck.y - paddleY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDist = PUCK_RADIUS + PADDLE_RADIUS;

      if (distance < minDist && distance > 0) {
        // 衝突！パックを押し出す
        const overlap = minDist - distance;
        const nx = dx / distance; // 法線ベクトル（パドルからパックへの方向）
        const ny = dy / distance;

        // パックを押し出す
        puck.x += nx * overlap;
        puck.y += ny * overlap;

        // パドルの速度
        const paddleSpeed = Math.sqrt(paddleVx * paddleVx + paddleVy * paddleVy);

        // パドルが相手ゴール方向（上方向）に動いているか
        const isMovingForward = paddleY < CANVAS_HEIGHT / 2 ? paddleVy > 0 : paddleVy < 0;

        if (paddleSpeed < 0.5) {
          // パドルが静止している場合
          const puckSpeed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);

          if (puckSpeed < 0.5) {
            // パックも静止：パドルから離れる方向に発射
            puck.vx = nx * PUCK_SPEED;
            puck.vy = ny * PUCK_SPEED;
          } else {
            // パックが動いている：反射
            const dot = puck.vx * nx + puck.vy * ny;
            puck.vx = (puck.vx - 2 * dot * nx) * RESTITUTION;
            puck.vy = (puck.vy - 2 * dot * ny) * RESTITUTION;
          }
        } else {
          // パドルが動いている：パドルの動きをパックに伝える

          // パドルの進行方向に基づいて打ち返す力を計算
          const hitStrength = Math.max(paddleSpeed * 1.5, PUCK_SPEED);

          // パックが自陣方向に飛びそうな場合は補正
          const forwardDir = paddleY < CANVAS_HEIGHT / 2 ? 1 : -1;  // 上半分は下向き、下半分は上向き
          let finalNy = ny;

          // パックが後ろに飛びそうで、パドルが前進中なら補正
          if (ny * forwardDir > 0 && isMovingForward) {
            // パドルの横位置によって角度を決定
            const xOffset = dx / PADDLE_RADIUS;
            finalNy = -Math.abs(ny) * forwardDir * -1;
            const finalNx = xOffset * 0.8;
            const len = Math.sqrt(finalNx * finalNx + finalNy * finalNy);
            if (len > 0) {
              puck.vx = (finalNx / len) * hitStrength + paddleVx * 0.3;
              puck.vy = (finalNy / len) * hitStrength;
            }
          } else {
            // 通常の衝突
            puck.vx = nx * hitStrength + paddleVx * 0.3;
            puck.vy = ny * hitStrength + paddleVy * 0.3;
          }
        }

        // 速度制限を適用
        const newSpeed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
        if (newSpeed > PUCK_SPEED_LIMIT) {
          puck.vx = (puck.vx / newSpeed) * PUCK_SPEED_LIMIT;
          puck.vy = (puck.vy / newSpeed) * PUCK_SPEED_LIMIT;
        }

        // パドル衝突音を鳴らす
        playPaddleHit();

        // 衝突後すぐにパック状態を送信
        sendPuckState();
        return true;
      }
      return false;
    }

    // 旧バージョンの関数（互換性のため残す）
    function checkPaddleCollision(paddleX, paddleY) {
      return checkStaticPaddleCollision(paddleX, paddleY, 0, 0);
    }

    // Y座標を反転（ゲスト用）
    function flipY(y) {
      return CANVAS_HEIGHT - y;
    }

    // ========================================
    // 描画
    // ========================================
    function draw() {
      // 背景
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // センターライン
      ctx.strokeStyle = '#ffffff33';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(0, CANVAS_HEIGHT / 2);
      ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT / 2);
      ctx.stroke();
      ctx.setLineDash([]);

      // センターサークル
      ctx.beginPath();
      ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 50, 0, Math.PI * 2);
      ctx.stroke();

      // ゴールエリア
      const goalLeft = (CANVAS_WIDTH - GOAL_WIDTH) / 2;

      // ゴールの色（自分のゴールが下）
      const myGoalColor = isHost ? '#e9456066' : '#0f346066';  // ホスト=赤、ゲスト=青
      const oppGoalColor = isHost ? '#0f346066' : '#e9456066';

      // 上ゴール（相手のゴール）
      ctx.fillStyle = oppGoalColor;
      ctx.fillRect(goalLeft, 0, GOAL_WIDTH, 10);

      // 下ゴール（自分のゴール）
      ctx.fillStyle = myGoalColor;
      ctx.fillRect(goalLeft, CANVAS_HEIGHT - 10, GOAL_WIDTH, 10);

      // 相手のパドル位置（ゲストは反転して表示）
      const oppDrawX = opponentPaddleX;
      const oppDrawY = isHost ? opponentPaddleY : flipY(opponentPaddleY);

      // パックの描画位置（ゲストはY座標を反転）
      const puckDrawX = puck.x;
      const puckDrawY = isHost ? puck.y : flipY(puck.y);

      // パドル（上側・相手）
      ctx.fillStyle = isHost ? '#0f3460' : '#e94560';  // ホスト視点:青、ゲスト視点:赤
      ctx.beginPath();
      ctx.arc(oppDrawX, oppDrawY, PADDLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = isHost ? '#4a90d9' : '#ff6b8a';
      ctx.lineWidth = 3;
      ctx.stroke();

      // パドル（下側・自分）
      ctx.fillStyle = isHost ? '#e94560' : '#0f3460';  // ホスト=赤、ゲスト=青
      ctx.beginPath();
      ctx.arc(myPaddleX, myPaddleY, PADDLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = isHost ? '#ff6b8a' : '#4a90d9';
      ctx.lineWidth = 3;
      ctx.stroke();

      // パック
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(puckDrawX, puckDrawY, PUCK_RADIUS, 0, Math.PI * 2);
      ctx.fill();

      // パックの影
      ctx.fillStyle = '#00000033';
      ctx.beginPath();
      ctx.ellipse(puckDrawX + 3, puckDrawY + 3, PUCK_RADIUS, PUCK_RADIUS * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // ========================================
    // 通信
    // ========================================
    function sendPaddlePosition() {
      if (!client || !client.isConnected) return;
      try {
        // ゲストはY座標を反転してホスト座標系で送信
        const sendY = isHost ? myPaddleY : flipY(myPaddleY);
        client.send({ type: 'paddle', x: myPaddleX, y: sendY });
      } catch (e) {
        // 接続が完全に開いていない場合は無視
      }
    }

    function sendPuckState() {
      if (!client || !client.isConnected || !isHost) return;
      try {
        client.send({
          type: 'puck',
          x: puck.x,
          y: puck.y,
          vx: puck.vx,
          vy: puck.vy
        });
      } catch (e) {
        // 接続が完全に開いていない場合は無視
      }
    }

    function sendGoal(scorer) {
      if (!client || !client.isConnected) return;
      try {
        client.send({
          type: 'goal',
          scorer: scorer,
          hostScore: hostScore,
          guestScore: guestScore
        });
        updateScoreDisplay();
      } catch (e) {
        // 接続が完全に開いていない場合は無視
      }
    }

    function sendReset() {
      if (!client || !client.isConnected) return;
      try {
        client.send({ type: 'reset' });
      } catch (e) {
        // 接続が完全に開いていない場合は無視
      }
    }

    function receiveMessage(data) {
      switch (data.type) {
        case 'paddle':
          opponentPaddleX = data.x;
          opponentPaddleY = data.y;
          break;
        case 'puck':
          if (!isHost) {
            // サーバーとの位置差を計算して補間
            const dx = data.x - puck.x;
            const dy = data.y - puck.y;
            puck.x += dx * LERP_FACTOR;
            puck.y += dy * LERP_FACTOR;

            // 速度は常にサーバーの値を使用
            puck.vx = data.vx;
            puck.vy = data.vy;
          }
          break;
        case 'goal':
          hostScore = data.hostScore;
          guestScore = data.guestScore;
          updateScoreDisplay();
          // ゲスト側でもゴール演出を開始（scorerがhostならホストが得点＝ゲストのゴール）
          startGoalEffect(data.scorer === 'guest');
          if (hostScore >= WINNING_SCORE) {
            endGame('host');
          } else if (guestScore >= WINNING_SCORE) {
            endGame('guest');
          } else {
            // ゲスト側でもパックをリセット
            resetPuck();
          }
          break;
        case 'reset':
          resetGame(false);
          break;
      }
    }

    // ========================================
    // ゲーム終了
    // ========================================
    function endGame(winner) {
      gameOver = true;
      stopGameLoop();

      const isWin = (isHost && winner === 'host') || (!isHost && winner === 'guest');
      elements.result.textContent = isWin ? '勝利!' : '敗北...';
      elements.result.className = 'result ' + (isWin ? 'win' : 'lose');
      elements.result.style.display = 'block';
      elements.btnRematch.style.display = 'block';
    }

    function resetGame(notify = true) {
      gameOver = false;
      hostScore = 0;
      guestScore = 0;
      updateScoreDisplay();
      resetPuck();
      elements.result.style.display = 'none';
      elements.btnRematch.style.display = 'none';

      if (notify) {
        sendReset();
      }

      startGameLoop();
    }

    // ========================================
    // 入力処理
    // ========================================
    function setupInput() {
      // パドル位置を更新する共通関数
      function updatePaddlePosition(clientX, clientY) {
        if (gameOver) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = CANVAS_WIDTH / rect.width;
        const scaleY = CANVAS_HEIGHT / rect.height;

        let newX = (clientX - rect.left) * scaleX;
        let newY = (clientY - rect.top) * scaleY;

        // パドルの移動範囲を制限（常に下半分）
        const minY = CANVAS_HEIGHT / 2 + PADDLE_RADIUS;
        const maxY = CANVAS_HEIGHT - PADDLE_RADIUS;

        // X方向の制限
        newX = Math.max(PADDLE_RADIUS, Math.min(CANVAS_WIDTH - PADDLE_RADIUS, newX));
        // Y方向の制限
        newY = Math.max(minY, Math.min(maxY, newY));

        myPaddleX = newX;
        myPaddleY = newY;

        sendPaddlePosition();
      }

      // マウス移動
      canvas.addEventListener('mousemove', (e) => {
        updatePaddlePosition(e.clientX, e.clientY);
      });

      // タッチ移動
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        updatePaddlePosition(touch.clientX, touch.clientY);
      }, { passive: false });

      // タッチ開始
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        updatePaddlePosition(touch.clientX, touch.clientY);
      }, { passive: false });
    }

    // ========================================
    // 初期化
    // ========================================
    async function init() {
      // Canvas設定
      canvas = elements.gameCanvas;
      ctx = canvas.getContext('2d');

      // localStorage から読み込み
      const stored = loadFromStorage();

      // 名前がなければ生成
      const myName = stored.myName || generateName();
      if (!stored.myName) {
        saveToStorage(STORAGE_KEYS.MY_NAME, myName);
      }

      // UI更新
      elements.myName.textContent = myName;
      elements.myId.textContent = stored.myId ? `ID: ${stored.myId}` : 'ID: 未登録';

      // 名前編集ボタン
      elements.btnEditName.addEventListener('click', () => {
        const currentName = elements.myName.textContent;
        const newName = prompt('新しい名前を入力してください:', currentName);
        if (newName && newName.trim()) {
          const trimmedName = newName.trim();
          saveToStorage(STORAGE_KEYS.MY_NAME, trimmedName);
          elements.myName.textContent = trimmedName;
        }
      });

      // 設定UIの初期化
      elements.inputPassphrase.value = stored.passphrase;
      renderFriendList(stored.friendList);

      // 設定トグル
      elements.settingsToggle.addEventListener('click', () => {
        elements.settingsToggle.classList.toggle('open');
        elements.settingsContent.classList.toggle('open');
      });

      // あいことば変更
      elements.inputPassphrase.addEventListener('change', () => {
        saveToStorage(STORAGE_KEYS.PASSPHRASE, elements.inputPassphrase.value);
      });

      // フレンド追加
      elements.btnAddFriend.addEventListener('click', () => {
        const friendId = elements.inputFriendId.value.trim();
        if (friendId) {
          const newList = addFriend(friendId);
          renderFriendList(newList);
          elements.inputFriendId.value = '';
        }
      });

      // フレンド削除（イベント委譲）
      elements.friendListContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('friend-remove')) {
          const friendId = e.target.dataset.id;
          const newList = removeFriend(friendId);
          renderFriendList(newList);
        }
      });

      // 入力設定
      setupInput();

      // マッチング開始ボタン
      elements.btnStart.addEventListener('click', async () => {
        try {
          // AudioContextを初期化（ユーザー操作をきっかけに）
          initAudio();

          elements.btnStart.disabled = true;
          setStatus('IP取得中...');

          // グローバルIP取得
          const globalIp = await getGlobalIp();

          setStatus('登録中...');

          // 現在の設定値を取得
          const currentPassphrase = elements.inputPassphrase.value.trim();
          const currentFriendList = loadFromStorage().friendList;

          // クライアント作成
          client = new WebRTCGAS.Client({
            apiUrl: API_URL,
            name: myName,
            id: stored.myId,
            globalIp: globalIp,
            friendList: currentFriendList,
            passphrase: currentPassphrase,
            pollingInterval: 2000
          });

          // イベント設定
          client.on('registered', (data) => {
            saveToStorage(STORAGE_KEYS.MY_ID, data.id);
            elements.myId.textContent = `ID: ${data.id}`;
            setStatus('マッチング中...');
          });

          client.on('matchFound', (data) => {
            if (data.matchList.length > 0 && !client.peerId) {
              connectToPeer(data.matchList[0].id);
            }
          });

          client.on('offer', (data) => {
            setStatus('接続中...');
          });

          client.on('connected', (data) => {
            // 接続完了をAPIに報告
            fetch(API_URL, {
              method: 'POST',
              body: JSON.stringify({
                action: 'sendsignal',
                id: client.id,
                peer_id: client.peerId,
                status: 'connected',
                type: 'polling'
              }),
              redirect: 'follow'
            }).catch(() => {});

            // データチャネルが開くまで待ってからゲーム開始
            waitForDataChannel().then(() => {
              initGame(client._isOfferer);
            });
          });

          client.on('message', (data) => {
            receiveMessage(data.data);
          });

          client.on('disconnected', (data) => {
            alert('接続が切断されました');
            location.reload();
          });

          client.on('error', (data) => {
            setStatus('エラー: ' + data.error.message, true);
            elements.btnStart.disabled = false;
          });

          client.on('reset', (data) => {
            alert('接続エラーが発生しました。再接続します。');
            location.reload();
          });

          // 登録
          await client.register();

        } catch (error) {
          setStatus('エラー: ' + error.message, true);
          elements.btnStart.disabled = false;
        }
      });

      // もう一度ボタン
      elements.btnRematch.addEventListener('click', () => resetGame(true));

      // 切断ボタン
      elements.btnDisconnect.addEventListener('click', () => {
        if (client) {
          client.disconnect();
        }
        location.reload();
      });
    }

    // 起動
    init();
  </script>
</body>
</html>
