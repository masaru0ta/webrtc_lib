<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>エアホッケー - WebRTC-GAS サンプル</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      max-width: 450px;
      width: 100%;
      text-align: center;
    }

    h1 {
      color: #333;
      margin-bottom: 20px;
      font-size: 24px;
    }

    .screen {
      display: none;
    }

    .screen.active {
      display: block;
    }

    .player-info {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .player-name {
      font-size: 20px;
      font-weight: bold;
      color: #e94560;
    }

    .player-id {
      font-size: 12px;
      color: #999;
      margin-top: 5px;
    }

    .btn {
      background: linear-gradient(135deg, #e94560 0%, #0f3460 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 16px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      width: 100%;
      margin-bottom: 10px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: #f5f5f5;
      color: #333;
    }

    .btn-secondary:hover {
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }

    .status {
      color: #666;
      margin: 15px 0;
      font-size: 14px;
    }

    .status.error {
      color: #e74c3c;
    }

    /* ゲーム画面 */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .score-display {
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 24px;
      font-weight: bold;
    }

    .score {
      padding: 10px 20px;
      border-radius: 10px;
      min-width: 60px;
    }

    .score.opponent {
      background: #e94560;
      color: white;
    }

    .score.mine {
      background: #0f3460;
      color: white;
    }

    .score-separator {
      color: #333;
    }

    .opponent-name {
      font-size: 14px;
      color: #666;
    }

    #game-canvas {
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      touch-action: none;
      max-width: 100%;
    }

    .result {
      font-size: 24px;
      font-weight: bold;
      margin: 20px 0;
      padding: 15px;
      border-radius: 10px;
    }

    .result.win {
      background: #d4edda;
      color: #155724;
    }

    .result.lose {
      background: #f8d7da;
      color: #721c24;
    }

    .game-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .game-buttons .btn {
      flex: 1;
    }

    /* ローディング */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #e94560;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>エアホッケー</h1>

    <!-- ロビー画面 -->
    <div id="screen-lobby" class="screen active">
      <div class="player-info">
        <div class="player-name" id="my-name">-</div>
        <div class="player-id" id="my-id">ID: -</div>
      </div>

      <button class="btn" id="btn-start">マッチング開始</button>

      <div class="status" id="status">準備完了</div>
    </div>

    <!-- ゲーム画面 -->
    <div id="screen-game" class="screen">
      <div class="game-header">
        <div class="opponent-name">VS <span id="opponent-name">-</span></div>
        <div class="score-display">
          <div class="score opponent" id="opponent-score">0</div>
          <span class="score-separator">-</span>
          <div class="score mine" id="my-score">0</div>
        </div>
      </div>

      <canvas id="game-canvas" width="400" height="500"></canvas>

      <div class="result" id="result" style="display: none;"></div>

      <div class="game-buttons">
        <button class="btn" id="btn-rematch" style="display: none;">もう一度</button>
        <button class="btn btn-secondary" id="btn-disconnect">切断</button>
      </div>
    </div>
  </div>

  <script src="../src/webrtc-gas.js"></script>
  <script>
    // ========================================
    // 定数
    // ========================================
    const API_URL = 'https://script.google.com/macros/s/AKfycbz9RbzxrYV8QbsclJcwNYhO4JoE9qQZlD-aWX5Z5U9jICPBEiBbEznf3scgQx8GONZa1A/exec';

    const ZODIAC_NAMES = [
      'ねずみ', 'うし', 'とら', 'うさぎ', 'たつ', 'へび',
      'うま', 'ひつじ', 'さる', 'とり', 'いぬ', 'いのしし'
    ];

    const STORAGE_KEYS = {
      MY_ID: 'airhockey_myId',
      MY_NAME: 'airhockey_myName',
      FRIEND_LIST: 'airhockey_friendList'
    };

    // ゲーム定数
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 500;
    const PADDLE_RADIUS = 30; // 丸いパドル
    const PUCK_RADIUS = 15;
    const GOAL_WIDTH = 120;
    const WINNING_SCORE = 5;
    const PUCK_SPEED = 5;

    // ========================================
    // ゲーム状態
    // ========================================
    let client = null;
    let canvas = null;
    let ctx = null;
    let isHost = false;
    let gameOver = false;
    let animationId = null;

    // スコア
    let hostScore = 0;
    let guestScore = 0;

    // パドル位置（X, Y位置）
    let myPaddleX = CANVAS_WIDTH / 2;
    let myPaddleY = 0;
    let opponentPaddleX = CANVAS_WIDTH / 2;
    let opponentPaddleY = 0;

    // パック状態（ホストが管理）
    let puck = {
      x: CANVAS_WIDTH / 2,
      y: CANVAS_HEIGHT / 2,
      vx: 0,
      vy: 0
    };

    // ========================================
    // DOM要素
    // ========================================
    const elements = {
      screenLobby: document.getElementById('screen-lobby'),
      screenGame: document.getElementById('screen-game'),
      myName: document.getElementById('my-name'),
      myId: document.getElementById('my-id'),
      btnStart: document.getElementById('btn-start'),
      status: document.getElementById('status'),
      opponentName: document.getElementById('opponent-name'),
      opponentScore: document.getElementById('opponent-score'),
      myScore: document.getElementById('my-score'),
      gameCanvas: document.getElementById('game-canvas'),
      result: document.getElementById('result'),
      btnRematch: document.getElementById('btn-rematch'),
      btnDisconnect: document.getElementById('btn-disconnect')
    };

    // ========================================
    // localStorage 操作
    // ========================================
    function loadFromStorage() {
      return {
        myId: localStorage.getItem(STORAGE_KEYS.MY_ID) || null,
        myName: localStorage.getItem(STORAGE_KEYS.MY_NAME) || null,
        friendList: JSON.parse(localStorage.getItem(STORAGE_KEYS.FRIEND_LIST) || '[]')
      };
    }

    function saveToStorage(key, value) {
      if (key === STORAGE_KEYS.FRIEND_LIST) {
        localStorage.setItem(key, JSON.stringify(value));
      } else {
        localStorage.setItem(key, value);
      }
    }

    function addFriend(friendId) {
      const data = loadFromStorage();
      if (!data.friendList.includes(friendId)) {
        data.friendList.push(friendId);
        saveToStorage(STORAGE_KEYS.FRIEND_LIST, data.friendList);
      }
    }

    // ========================================
    // 名前生成
    // ========================================
    function generateName() {
      const index = Math.floor(Math.random() * ZODIAC_NAMES.length);
      return ZODIAC_NAMES[index];
    }

    // ========================================
    // グローバルIP取得
    // ========================================
    async function getGlobalIp() {
      try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return data.ip;
      } catch (error) {
        console.warn('グローバルIP取得失敗:', error);
        return '';
      }
    }

    // ========================================
    // 画面切り替え
    // ========================================
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
    }

    function setStatus(message, isError = false) {
      elements.status.textContent = message;
      elements.status.classList.toggle('error', isError);
    }

    // ========================================
    // 接続処理
    // ========================================
    async function connectToPeer(peerId) {
      try {
        setStatus('接続中...');
        elements.btnStart.disabled = true;

        await client.connect(peerId);

      } catch (error) {
        setStatus('接続エラー: ' + error.message, true);
        elements.btnStart.disabled = false;
      }
    }

    // ========================================
    // ゲーム初期化
    // ========================================
    function initGame(isOfferer) {
      isHost = isOfferer;
      gameOver = false;
      hostScore = 0;
      guestScore = 0;

      // パドル初期位置（自分は常に下半分）
      myPaddleX = CANVAS_WIDTH / 2;
      myPaddleY = CANVAS_HEIGHT * 3 / 4;
      opponentPaddleX = CANVAS_WIDTH / 2;
      opponentPaddleY = CANVAS_HEIGHT / 4;

      // パック初期化
      resetPuck();

      // フレンドリストに追加
      addFriend(client.peerId);

      // UI更新
      elements.opponentName.textContent = client.peerName || client.peerId;
      updateScoreDisplay();
      elements.result.style.display = 'none';
      elements.btnRematch.style.display = 'none';

      showScreen('screen-game');

      // ゲームループ開始
      startGameLoop();
    }

    function resetPuck() {
      puck.x = CANVAS_WIDTH / 2;
      puck.y = CANVAS_HEIGHT / 2;
      puck.vx = 0;
      puck.vy = 0;
    }

    function updateScoreDisplay() {
      if (isHost) {
        elements.myScore.textContent = hostScore;
        elements.opponentScore.textContent = guestScore;
      } else {
        elements.myScore.textContent = guestScore;
        elements.opponentScore.textContent = hostScore;
      }
    }

    // ========================================
    // ゲームループ
    // ========================================
    function startGameLoop() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      gameLoop();
    }

    function stopGameLoop() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function gameLoop() {
      if (gameOver) return;

      // ホストのみ物理演算
      if (isHost) {
        updatePuck();
      }

      // 描画
      draw();

      // デバッグ: 衝突判定用の情報を表示
      ctx.fillStyle = '#ffff00';
      ctx.font = '10px Arial';
      ctx.fillText(`isHost: ${isHost}`, 5, 15);
      ctx.fillText(`myPaddle: ${Math.round(myPaddleX)},${Math.round(myPaddleY)}`, 5, 27);
      ctx.fillText(`oppPaddle: ${Math.round(opponentPaddleX)},${Math.round(opponentPaddleY)}`, 5, 39);
      ctx.fillText(`puck: ${Math.round(puck.x)},${Math.round(puck.y)} v:${puck.vx.toFixed(1)},${puck.vy.toFixed(1)}`, 5, 51);

      animationId = requestAnimationFrame(gameLoop);
    }

    // ========================================
    // 物理演算（ホストのみ）
    // ========================================
    function updatePuck() {
      // パック移動
      puck.x += puck.vx;
      puck.y += puck.vy;

      // 左右の壁との衝突
      if (puck.x - PUCK_RADIUS <= 0) {
        puck.x = PUCK_RADIUS;
        puck.vx = -puck.vx;
      } else if (puck.x + PUCK_RADIUS >= CANVAS_WIDTH) {
        puck.x = CANVAS_WIDTH - PUCK_RADIUS;
        puck.vx = -puck.vx;
      }

      // ゴール判定（上下）
      const goalLeft = (CANVAS_WIDTH - GOAL_WIDTH) / 2;
      const goalRight = (CANVAS_WIDTH + GOAL_WIDTH) / 2;

      // 上ゴール（ゲストのゴール）
      if (puck.y - PUCK_RADIUS <= 0) {
        if (puck.x >= goalLeft && puck.x <= goalRight) {
          // ホストが得点
          hostScore++;
          sendGoal('host');
          if (hostScore >= WINNING_SCORE) {
            endGame('host');
          } else {
            resetPuck();
            sendPuckState();
          }
          return;
        } else {
          puck.y = PUCK_RADIUS;
          puck.vy = -puck.vy;
        }
      }

      // 下ゴール（ホストのゴール）
      if (puck.y + PUCK_RADIUS >= CANVAS_HEIGHT) {
        if (puck.x >= goalLeft && puck.x <= goalRight) {
          // ゲストが得点
          guestScore++;
          sendGoal('guest');
          if (guestScore >= WINNING_SCORE) {
            endGame('guest');
          } else {
            resetPuck();
            sendPuckState();
          }
          return;
        } else {
          puck.y = CANVAS_HEIGHT - PUCK_RADIUS;
          puck.vy = -puck.vy;
        }
      }

      // パドルとの衝突（円同士）
      // ホストのパドル（下半分）
      const hostPaddleX = isHost ? myPaddleX : opponentPaddleX;
      const hostPaddleY = isHost ? myPaddleY : opponentPaddleY;
      checkPaddleCollision(hostPaddleX, hostPaddleY);

      // ゲストのパドル（上半分）
      const guestPaddleX = isHost ? opponentPaddleX : myPaddleX;
      const guestPaddleY = isHost ? opponentPaddleY : myPaddleY;
      checkPaddleCollision(guestPaddleX, guestPaddleY);

      // パック状態を送信（5フレームに1回）
      if (Math.random() < 0.2) {
        sendPuckState();
      }
    }

    // パドルとパックの衝突判定（円同士）
    function checkPaddleCollision(paddleX, paddleY) {
      const dx = puck.x - paddleX;
      const dy = puck.y - paddleY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDist = PUCK_RADIUS + PADDLE_RADIUS;

      if (distance < minDist && distance > 0) {
        // 衝突！ パックを押し出す
        const overlap = minDist - distance;
        const nx = dx / distance; // 法線ベクトル
        const ny = dy / distance;

        // パックを押し出す
        puck.x += nx * overlap;
        puck.y += ny * overlap;

        // パックの速度を計算
        const speed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);

        if (speed < 0.1) {
          // パックが静止している場合、パドルから離れる方向に発射
          puck.vx = nx * PUCK_SPEED;
          puck.vy = ny * PUCK_SPEED;
        } else {
          // 反射ベクトルを計算
          const dot = puck.vx * nx + puck.vy * ny;
          puck.vx = puck.vx - 2 * dot * nx;
          puck.vy = puck.vy - 2 * dot * ny;

          // 速度を正規化して一定速度を維持
          const newSpeed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
          if (newSpeed > 0) {
            puck.vx = (puck.vx / newSpeed) * PUCK_SPEED * 1.1;
            puck.vy = (puck.vy / newSpeed) * PUCK_SPEED * 1.1;
          }
        }
      }
    }

    // Y座標を反転（ゲスト用）
    function flipY(y) {
      return CANVAS_HEIGHT - y;
    }

    // ========================================
    // 描画
    // ========================================
    function draw() {
      // 背景
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // センターライン
      ctx.strokeStyle = '#ffffff33';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(0, CANVAS_HEIGHT / 2);
      ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT / 2);
      ctx.stroke();
      ctx.setLineDash([]);

      // センターサークル
      ctx.beginPath();
      ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 50, 0, Math.PI * 2);
      ctx.stroke();

      // ゴールエリア
      const goalLeft = (CANVAS_WIDTH - GOAL_WIDTH) / 2;

      // ゴールの色（自分のゴールが下）
      const myGoalColor = isHost ? '#e9456066' : '#0f346066';  // ホスト=赤、ゲスト=青
      const oppGoalColor = isHost ? '#0f346066' : '#e9456066';

      // 上ゴール（相手のゴール）
      ctx.fillStyle = oppGoalColor;
      ctx.fillRect(goalLeft, 0, GOAL_WIDTH, 10);

      // 下ゴール（自分のゴール）
      ctx.fillStyle = myGoalColor;
      ctx.fillRect(goalLeft, CANVAS_HEIGHT - 10, GOAL_WIDTH, 10);

      // 相手のパドル位置（ゲストは反転して表示）
      const oppDrawX = opponentPaddleX;
      const oppDrawY = isHost ? opponentPaddleY : flipY(opponentPaddleY);

      // パックの描画位置（ゲストは反転して表示）
      const puckDrawX = puck.x;
      const puckDrawY = isHost ? puck.y : flipY(puck.y);

      // パドル（上側・相手）
      ctx.fillStyle = isHost ? '#0f3460' : '#e94560';  // ホスト視点:青、ゲスト視点:赤
      ctx.beginPath();
      ctx.arc(oppDrawX, oppDrawY, PADDLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = isHost ? '#4a90d9' : '#ff6b8a';
      ctx.lineWidth = 3;
      ctx.stroke();

      // パドル（下側・自分）
      ctx.fillStyle = isHost ? '#e94560' : '#0f3460';  // ホスト=赤、ゲスト=青
      ctx.beginPath();
      ctx.arc(myPaddleX, myPaddleY, PADDLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = isHost ? '#ff6b8a' : '#4a90d9';
      ctx.lineWidth = 3;
      ctx.stroke();

      // パック
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(puckDrawX, puckDrawY, PUCK_RADIUS, 0, Math.PI * 2);
      ctx.fill();

      // パックの影
      ctx.fillStyle = '#00000033';
      ctx.beginPath();
      ctx.ellipse(puckDrawX + 3, puckDrawY + 3, PUCK_RADIUS, PUCK_RADIUS * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // ========================================
    // 通信
    // ========================================
    function sendPaddlePosition() {
      if (!client || !client.isConnected) return;
      // ゲストはY座標を反転してホスト座標系で送信
      const sendY = isHost ? myPaddleY : flipY(myPaddleY);
      client.send({ type: 'paddle', x: myPaddleX, y: sendY });
    }

    function sendPuckState() {
      if (!client || !client.isConnected || !isHost) return;
      client.send({
        type: 'puck',
        x: puck.x,
        y: puck.y,
        vx: puck.vx,
        vy: puck.vy
      });
    }

    function sendGoal(scorer) {
      if (!client || !client.isConnected) return;
      client.send({
        type: 'goal',
        scorer: scorer,
        hostScore: hostScore,
        guestScore: guestScore
      });
      updateScoreDisplay();
    }

    function sendReset() {
      if (!client || !client.isConnected) return;
      client.send({ type: 'reset' });
    }

    function receiveMessage(data) {
      switch (data.type) {
        case 'paddle':
          opponentPaddleX = data.x;
          opponentPaddleY = data.y;
          break;
        case 'puck':
          if (!isHost) {
            puck.x = data.x;
            puck.y = data.y;
            puck.vx = data.vx;
            puck.vy = data.vy;
          }
          break;
        case 'goal':
          hostScore = data.hostScore;
          guestScore = data.guestScore;
          updateScoreDisplay();
          if (hostScore >= WINNING_SCORE) {
            endGame('host');
          } else if (guestScore >= WINNING_SCORE) {
            endGame('guest');
          }
          break;
        case 'reset':
          resetGame(false);
          break;
      }
    }

    // ========================================
    // ゲーム終了
    // ========================================
    function endGame(winner) {
      gameOver = true;
      stopGameLoop();

      const isWin = (isHost && winner === 'host') || (!isHost && winner === 'guest');
      elements.result.textContent = isWin ? '勝利!' : '敗北...';
      elements.result.className = 'result ' + (isWin ? 'win' : 'lose');
      elements.result.style.display = 'block';
      elements.btnRematch.style.display = 'block';
    }

    function resetGame(notify = true) {
      gameOver = false;
      hostScore = 0;
      guestScore = 0;
      updateScoreDisplay();
      resetPuck();
      elements.result.style.display = 'none';
      elements.btnRematch.style.display = 'none';

      if (notify) {
        sendReset();
      }

      startGameLoop();
    }

    // ========================================
    // 入力処理
    // ========================================
    function setupInput() {
      // パドル位置を更新する共通関数
      function updatePaddlePosition(clientX, clientY) {
        if (gameOver) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = CANVAS_WIDTH / rect.width;
        const scaleY = CANVAS_HEIGHT / rect.height;

        let newX = (clientX - rect.left) * scaleX;
        let newY = (clientY - rect.top) * scaleY;

        // パドルの移動範囲を制限（常に下半分）
        const minY = CANVAS_HEIGHT / 2 + PADDLE_RADIUS;
        const maxY = CANVAS_HEIGHT - PADDLE_RADIUS;

        // X方向の制限
        newX = Math.max(PADDLE_RADIUS, Math.min(CANVAS_WIDTH - PADDLE_RADIUS, newX));
        // Y方向の制限
        newY = Math.max(minY, Math.min(maxY, newY));

        myPaddleX = newX;
        myPaddleY = newY;

        sendPaddlePosition();
      }

      // マウス移動
      canvas.addEventListener('mousemove', (e) => {
        updatePaddlePosition(e.clientX, e.clientY);
      });

      // タッチ移動
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        updatePaddlePosition(touch.clientX, touch.clientY);
      }, { passive: false });

      // タッチ開始
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        updatePaddlePosition(touch.clientX, touch.clientY);
      }, { passive: false });
    }

    // ========================================
    // 初期化
    // ========================================
    async function init() {
      // Canvas設定
      canvas = elements.gameCanvas;
      ctx = canvas.getContext('2d');

      // localStorage から読み込み
      const stored = loadFromStorage();

      // 名前がなければ生成
      const myName = stored.myName || generateName();
      if (!stored.myName) {
        saveToStorage(STORAGE_KEYS.MY_NAME, myName);
      }

      // UI更新
      elements.myName.textContent = myName;
      elements.myId.textContent = stored.myId ? `ID: ${stored.myId}` : 'ID: 未登録';

      // 入力設定
      setupInput();

      // マッチング開始ボタン
      elements.btnStart.addEventListener('click', async () => {
        try {
          elements.btnStart.disabled = true;
          setStatus('IP取得中...');

          // グローバルIP取得
          const globalIp = await getGlobalIp();

          setStatus('登録中...');

          // クライアント作成
          client = new WebRTCGAS.Client({
            apiUrl: API_URL,
            name: myName,
            id: stored.myId,
            globalIp: globalIp,
            friendList: stored.friendList,
            pollingInterval: 2000
          });

          // イベント設定
          client.on('registered', (data) => {
            saveToStorage(STORAGE_KEYS.MY_ID, data.id);
            elements.myId.textContent = `ID: ${data.id}`;
            setStatus('マッチング中...');
          });

          client.on('matchFound', (data) => {
            if (data.matchList.length > 0 && !client.peerId) {
              connectToPeer(data.matchList[0].id);
            }
          });

          client.on('offer', (data) => {
            setStatus('接続中...');
          });

          client.on('connected', (data) => {
            // 接続完了をAPIに報告
            fetch(API_URL, {
              method: 'POST',
              body: JSON.stringify({
                action: 'sendsignal',
                id: client.id,
                peer_id: client.peerId,
                status: 'connected',
                type: 'polling'
              }),
              redirect: 'follow'
            }).catch(() => {});

            initGame(client._isOfferer);
          });

          client.on('message', (data) => {
            receiveMessage(data.data);
          });

          client.on('disconnected', (data) => {
            alert('接続が切断されました');
            location.reload();
          });

          client.on('error', (data) => {
            setStatus('エラー: ' + data.error.message, true);
            elements.btnStart.disabled = false;
          });

          client.on('reset', (data) => {
            console.log('リセット:', data.message);
            alert('接続エラーが発生しました。再接続します。');
            location.reload();
          });

          // 登録
          await client.register();

        } catch (error) {
          setStatus('エラー: ' + error.message, true);
          elements.btnStart.disabled = false;
        }
      });

      // もう一度ボタン
      elements.btnRematch.addEventListener('click', () => resetGame(true));

      // 切断ボタン
      elements.btnDisconnect.addEventListener('click', () => {
        if (client) {
          client.disconnect();
        }
        location.reload();
      });
    }

    // 起動
    init();
  </script>
</body>
</html>
